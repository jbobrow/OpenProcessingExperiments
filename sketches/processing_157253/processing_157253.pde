
/*    Pierre Marzin 08/2014
 
 Just for fun: elements are disposed on a 'cube' grid knots. Their centers are spheres.
 They have 0 to 6 'limbs'(cylinders) pointing to neighbour knots(West/East/South/North/Up/Down): when two elements 'shake hands' they are linked
 This sketch just identify and shows the chains generated by linked elements...
 I use 3 classes: Chain, Element and Contact (the limbs extremities)
 */
Arcball arcball;//allows mouse driven 3d rotations
ArrayList<Element> elements;//the elements
ArrayList<Chain> chains;//the chains^^
int action=0;//action is used to show different steps of th algorithm
boolean done=false;//wether curent step is over
int nrangs;//how many horizontal lines in each plan of the grid
int ncols;//how many vertical lines in each plan of the grid
int nplans;//how many plans in the grid
int margin=50;//margin to center the grid
float ecartX, ecartY, ecartZ;//how far are the elements from each other

void setup() {
  size(600, 600, P3D);
  arcball = new Arcball();
  smooth(8);
  sphereDetail(12);//we dont want a complex sphere
  nrangs=int(random(3, 7));//grid 'size' is drawn by random
  ncols=int(random(nrangs/1.5, nrangs*1.5));//other dimensions are set not too different
  nplans=int(random(nrangs/1.5, nrangs*1.5));
}
void draw() {
  background(128);
  lights();//3d environment is set
  camera(0, 0, 1000, 0, 0, 0, 0, 1, 0);
  if (action==0) {//first step: the grid is created
    creategrid();
  }
  if (action==2 && !done) {//second step: linked elements are identified and chains are created
    findchains();
  }
  if (action==3 && !done) {//third step: single element chains are removed
    cleanchains();
  }
  //grid is rotated according to the mouse moves and elements are displayed
  pushMatrix();
  PVector axis = arcball.getAxis();
  rotate( -arcball.getAngle(), -axis.x, -axis.y, axis.z );
  for (int i=0; i<elements.size (); i++) {
    elements.get(i).display();
  }
  popMatrix();
}
void creategrid() {//first step: the grid is created
  elements=new ArrayList<Element>();     
  ecartX=(width-2*margin)/(ncols-1);
  ecartY=(height-2*margin)/(nrangs-1);    
  ecartZ=(height-2*margin)/(nplans-1);
  for (int k=0; k<nplans; k++) {
    for (i=0; i<ncols; i++) {
      for (int j=0; j<nrangs; j++) {
        Element e=new Element(margin+i*ecartX-width/2, margin+j*ecartY-height/2, width/2 -2*margin-k*ecartZ, ecartX, ecartY, ecartZ, j+i*nrangs+k*(nrangs*ncols));
        elements.add(e);
      }
    }
  }
}
void findchains() {//second step: linked elements are identified and chains are created
  chains=new ArrayList<Chain>();
  done=true;
  for (i=0; i<elements.size (); i++) {
    Element e=elements.get(i);
    if (!e.linked) {
      Chain newchain=new Chain();
      chains.add(newchain);
      newchain.addelement(e);
      e.chain=newchain;
      e.linked=true;
      e.lookforchain(newchain);
    }
  }
}
void cleanchains() {//third step: single element chains are removed
  done=true;
  for (int i=chains.size ()-1; i>-1; i--) {
    Chain c=chains.get(i);
    if (c.celements.size()==1) {
      elements.remove(c.celements.get(0));
      chains.remove(c);
    } 
    ;//else c.tostring();
  }
}
void mouseReleased() {//we will cycle through 4 steps, action will change at each click
  action++;
  action%=4;
  if (action==0) { 
    nrangs=int(random(3, 7));
    ncols=int(random(nrangs/1.5, nrangs*1.5));
    nplans=int(random(nrangs/1.5, nrangs*1.5));
  }
  done=false;
}
void mouseDragged()//when mouse is dragged, arcball mouseDragged method is called
{
  arcball.mouseDragged();
}
void cylinder(float radius, float haut, float faces) {// just drawing a cylinder, its axis: (0,0,0) to (0,0,haut)
  float angle=TWO_PI/faces;
  beginShape(QUADS);
  for (int f=0; f<faces; f++) {
    int f1=(f+1)%faces;   
    float sf=sin(f*angle); 
    float sf1=sin(f1*angle);
    float cf=cos(f*angle); 
    float cf1=cos(f1*angle);
    vertex(radius*sf, radius*cf, haut);
    vertex(radius*sf1, radius*cf1, haut);      
    vertex(radius*sf1, radius*cf1, 0);
    vertex(radius*sf, radius*cf, 0);
  }
  endShape(CLOSE);
}
class Chain {//chains of linked elements
  ArrayList<Element> celements=new ArrayList<Element>();
  color col=color(random(255), random(255), random(255));
  Chain() {
  }
  void addelement(Element e) {
    celements.add(e);
  }
  void tostring() {
    String s="";
    for (int i=0; i<celements.size (); i++) {
      s+=celements.get(i).index+" ";
    }
    println(s);
  }
}
class Element {
  int index;//index in the elements collection, 
  int n, p, q;// coordinates in the 3d grid
  Chain chain;//which chain does it belong to
  int elperplan=nrangs*ncols;//nb of elements in the plan
  boolean linked=false;//true when element is added to a chain(so we wont test it anymore)
  float w, h, d, x, y, z;//(w, h, d) dimensions of an element (x,y,z) center coordinates
  ArrayList<Contact> contacts;//collection of the element's limbs
  Element(float x, float y, float z, float w, float h, float d, int index) {
    contacts=new ArrayList<Contact>();
    this.index=index;
    this.w=w;
    this.h=h;
    this.d=d;
    this.x=x;
    this.y=y;
    this.z=z;
    q=int(index/elperplan);
    n=int((index-q*elperplan)/nrangs);    
    p=(index-q*elperplan)%nrangs;

    for (int i=0; i<6; i++) {//limbs are added randomly, or not... They point towards each direction
      if (random(1)>.5 && (i!=2 || p!=0)&& (i!=0 || p!=nrangs-1)&& (i!=3 || n!=0) && (i!=1 || n!=ncols-1)&& (i!=4 || q!=0)&& (i!=5 || q!=nplans-1))//no limb point outside the grid
        contacts.add(new Contact(i, contacts.size()));
    }
  }
  void lookforchain(Chain nchain) {//recursive method, to find and chain the linked elements
    for (int i=contacts.size ()-1; i>=0; i--) {
      Contact c=contacts.get(i);
      Element e=neighbour(c);
      if ((c.place==0&&e.hascontact(2))||(c.place==1&&e.hascontact(3))||
        (c.place==2&&e.hascontact(0))||(c.place==3&&e.hascontact(1))||
        (c.place==4&&e.hascontact(5))||(c.place==5&&e.hascontact(4))) {
        if (!e.linked) {
          e.linked=true;
          nchain.addelement(e);
          e.chain=nchain;
          e.lookforchain(nchain);
        }
      } else contacts.remove(c);
    }
  }
  boolean hascontact(int place) {//does this element have a limb pointing to this direction?
    boolean trouve=false;
    for (int i=0; i<contacts.size (); i++) {
      if (contacts.get(i).place==place)trouve=true;
    }
    return trouve;
  }
  Element neighbour(Contact c) {//which is the neighbour pointed by this limb?
    switch(c.place) {
    case 0:
      return elements.get(p+1+nrangs*n+(q*elperplan));
      break;
    case 2:
      return elements.get(p-1+nrangs*n+q*elperplan);
      break;
    case 1:
      return elements.get(p+nrangs*(n+1)+q*elperplan);
      break;
    case 3:
      return elements.get(p+nrangs*(n-1)+q*elperplan);
      break;
    case 4:
      return elements.get(p+nrangs*n+(q-1)*elperplan);
      break;
    case 5:
      return elements.get(p+nrangs*n+(q+1)*elperplan);
      break;
    default:
      return;
    }
  }
  void display() {//here we display the element, according to the different actions (steps)
    pushMatrix();
    translate(x, y, z);
    //println(x+" "+y+" "+z);
    for (int i=0; i<contacts.size (); i++) {
      Contact c=contacts.get(i);
      if (action>1) {
        fill(chain.col);
        noStroke();
      } else {
        noStroke();
        fill(0, 100);
      }
      pushMatrix();
      rotateY(abs(c.x)*PI/2);
      rotateX(abs(c.y)*PI/2);
      cylinder(w/30, (d*c.z+w*c.x-h*c.y)/2, 8);
      fill(0);
      popMatrix();
    }
    noStroke();
    if (chain==null)fill(255, 0, 0);
    else fill(chain.col);
    if (action!=3) {
      sphere(w/10);
    }
    popMatrix();
  }
}
class Contact {//the element's limbs. place is one of the directions, it's translated to coordinates
  int x, y, z;
  int index, place;
  Contact(int place, int index) {
    this.place=place;
    switch(place) {
    case 0:
      x=0;
      y=1;
      z=0;
      break;
    case 1:
      x=1;
      y=0;
      z=0;
      break;
    case 2:
      x=0;
      y=-1;
      z=0;
      break;
    case 3:
      x=-1;
      y=0;
      z=0;
      break;
    case 4:
      x=0;
      y=0;
      z=1;
      break;
    case 5:
      x=0;
      y=0;
      z=-1;
      break;
    }
    this.index=index;
  }
}


/*
  Adapted for use with processingJS by Pierre MARZIN 07/2014 from 
   Processing library 5th Feb 2006 by Tom Carden
  from "simple Arcball use template" 9.16.03 Simon Greenwold

  Heavily updated and moved to github in March 2012.
   
  Copyright (c) 2003 Simon Greenwold
  Copyright (c) 2006, 2012 Tom Carden

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General
  Public License along with this library; if not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
  Boston, MA  02111-1307  USA

*/

public class Arcball {

  PVector center;
  float radius;
  
  Quat qNow = new Quat(); 
  Quat qDrag;
  float dragFactor = 0.99f;

  /** defaults to radius of mag(width, height)/2 */
  public Arcball() {
    this(null, 0);
  }

  public Arcball(PVector center, float radius) {

    if (center == null) {
      float w = width;
      float h = height;
      if (radius == 0) {
        radius = mag(w, h) / 2.0f;
      }
      center = new PVector(w / 2.0f, h / 2.0f);
    }
    //parent.registerPre(this);

    this.center = center;
    this.radius = radius;
  }
  
  public void reset() {
    qNow = new Quat(); 
    qDrag = null;    
  }

  public void mousePressed() {
    qDrag = null;
  }
  
  public void mouseReleased() {
    updateDrag();
  }  

  public void mouseDragged() {
    updateDrag();
    qNow = qNow.multQ(qDrag);
  }
  
  private void updateDrag() {
    PVector pMouse = new PVector(pmouseX, pmouseY);
    PVector mouse = new PVector(mouseX, mouseY);
    PVector from = mouseOnSphere(pMouse);
    PVector to = mouseOnSphere(mouse);
    qDrag = new Quat(from.dot(to), from.cross(to));
  }

  public void pre() {
    if (dragFactor > 0.0 && !mousePressed && qDrag != null && qDrag.w < 0.999999) {
      qDrag.scaleAngle(dragFactor);
      qNow = Quat.mult(qNow, qDrag);
    }
  }

  private PVector mouseOnSphere(PVector mouse) {
    PVector v = new PVector();
    v.x = (mouse.x - center.x) / radius;
    v.y = (mouse.y - center.y) / radius;

    float mag = v.x * v.x + v.y * v.y;
    if (mag > 1.0f) {
      v.normalize();
    }
    else {
      v.z = sqrt(1.0f - mag);
    }
    return v;
  }

  public float getAngle() {
    return qNow.getAngle();
  }
  
  public PVector getAxis() {
    return qNow.getAxis();
  }

  // Quat!

  class Quat {
        
    float w, x, y, z;

    Quat() {
      reset();
    }

    Quat(float w, PVector v) {
      this.w = w;
      x = v.x;
      y = v.y;
      z = v.z;
    }

    Quat(float w, float x, float y, float z) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;
    }

    void reset() {
      w = 1.0f;
      x = 0.0f;
      y = 0.0f;
      z = 0.0f;
    }

    void set(float w, float x, float y, float z) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;
    }

    void set(float w, PVector v) {
      this.w = w;
      x = v.x;
      y = v.y;
      z = v.z;
    }

    void set(Quat q) {
      w = q.w;
      x = q.x;
      y = q.y;
      z = q.z;
    }

    Quat multQ(Quat q2) {
      Quat res = new Quat();
      res.w = w * q2.w - x * q2.x - y * q2.y - z * q2.z;
      res.x = w * q2.x + x * q2.w + y * q2.z - z * q2.y;
      res.y = w * q2.y + y * q2.w + z * q2.x - x * q2.z;
      res.z = w * q2.z + z * q2.w + x * q2.y - y * q2.x;
      return res;
    }

    float[] getValue() {
      // transforming this quat into an angle and an axis vector...

      float[] res = new float[4];

      float sa = (float) Math.sqrt(1.0f - w * w);
      if (sa < EPSILON) {
        sa = 1.0f;
      }

      res[0] = (float) Math.acos(w) * 2.0f;
      res[1] = x / sa;
      res[2] = y / sa;
      res[3] = z / sa;

      return res;
    }
    
    float getAngle() {
      return acos(w) * 2.0f;
    }
    
    PVector getAxis() {
      float sa = (float) sqrt(1.0f - w * w);
      if (sa < EPSILON) {
        sa = 1.0f;
      }
      return new PVector(x / sa, y / sa, z / sa);      
    }

    // these are a bit sketchy because they've been written without concern for whetherthe quat remains a unit quat :-/

    void scaleAngle(float scale) {
      setAngle(scale * getAngle());
    }    
    
    void setAngle(float angle) {
      PVector axis = getAxis();
      w = cos(angle / 2.0f);
      float scale = sin(angle / 2.0f);
      x = axis.x * scale;
      y = axis.y * scale;
      z = axis.z * scale;      
    }
    
  } // Quat

}



