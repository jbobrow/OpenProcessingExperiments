
//Chris_Scott
//DSDN142 - Project 3 - Interactive Toy.
////////////////////////////////////////

//Call Minim Libs
import ddf.minim.analysis.*;
import ddf.minim.*;
import ddf.minim.signals.*;

Minim minim;
AudioInput in;
AudioOutput out;
FFT fft;
SineWave sine;

//Audio Related Veriables.

float freq = 440;
float amp = 0.5;
float samples = 44100;

//Ship Related | Need to remove no longer used veriables. 

float x0;                                                                       //ship anchor.x.
float mX;                                                                       //ship anchor.x2.

PImage fade;                                                                    //Saves graphical data, generated by Audio, to give trail.

PVector shipLoc;                                                                //Determins location.
PVector shipVel;                                                                //Veolocity/Speed of ship.
PVector gravity;                                                                //Adds a sense of gravity to ship.
PVector thrust;                                                                 //Graphic of thrust activation.
boolean thrustOn = false;                                                       //If thrust on or off.
boolean toyNew;                                                                 //If toy is active or not.
boolean mouseC = false;

float movement;
float flight;
float yFlight;

float volume = 0;                                                               //Volume data value.
float volumeF = 0;                                                              //Fetch Volume as data.

PVector offset;
Star[] stars;                                                                   //Star Array.

void setup()
{
size (500, 800, P3D);
x0 = width / 2;
mX = x0;
minim = new Minim(this);
minim.debugOn();

//input sound.
in = minim.getLineIn(Minim.MONO, 512);
fft = new FFT(in.bufferSize(), in.sampleRate());
fft.logAverages(60, 7);                                                        //Logs Octaves&Frequency then Averages them into data.

//output sound.
out = minim.getLineOut(Minim.STEREO, 512);
sine = new SineWave(freq, amp, samples);
out.addSignal(sine);

stroke(225);
smooth();
background(0);
fade = get(0, 0, width, 600);


initialize();
getVolume();

toyNew = true;


//Initialize Stars(background)
stars = new Star[width];
for(int s = 0; s < stars.length; s ++) stars[s] = new Star();
offset = new PVector(width / 2, height / 2);

}

void getVolume()
{
volumeF = in.right.level()*1000;
volume = 0.80*volume + 0.4*volumeF;
}


void initialize()
{

shipVel = new PVector(0, 0);
thrust = new PVector(0, 0);
gravity = new PVector(0, 0.002);

flight = 0;
yFlight = 0;
movement = 100;
toyNew = false;

shipLoc = new PVector(0, 700); //Starting location of ship.
}


void draw()
{
 
//Colors to sound.

color myColor = get(mouseX, mouseY);

float freq = map(int(floor(brightness(myColor))), 0, 255, 50, 600);
sine.setFreq(freq);

float amp = map(int(floor(saturation(myColor))), 0, 255,0.3, 2.00);
sine.setAmp(amp);  
 
background(0);

//Draws thruster data from Audio.

fft.forward(in.mix);

//Ship Conditions.

if (movement == 0) {
thrust = new PVector(0, 0);
thrustOn = false;
}
else
{
thrust = new PVector(sin(flight) * 0.015, cos(flight) * -0.015);
}


if (toyNew) {
thrustOn = false;
}
else {

shipVel.add(thrust);
shipVel.add(gravity);
shipLoc.add(shipVel);

}

drawShip();

//Starfield

for (int s = 0; s < stars.length; s ++) stars[s].display();

//Offset follows mousex/y, shipLoc.x/y... still to decide....

PVector angle = new PVector(shipLoc.x, shipLoc.y/2);
angle.normalize();
angle.mult(dist(width / 2, height / 2, shipLoc.x, shipLoc.y) / 100);
offset.add(angle);

}

class Star {
PVector loc;
int size;
int bright;
Star()
{
size = (int) random(1,4);
loc = new PVector(random(width * map(size, 1, 7, 7, 1)), random(height * map(size, 1, 7, 7, 1)));
bright = (int) random(204, 255);
}
void display() {
pushStyle();
stroke(bright);
strokeWeight(size);
int x = (int) (((loc.x - offset.x) * size / 8)) % width;
int y = (int) (((loc.y - offset.y) * size / 8)) % height;
if(x < 0) x += width;
if(y < 0) y += height;
point(x, y);
popStyle();
}
}

//End Starfield

void mouseMoved()
{
x0 = mouseX;
}


void drawShip()
{


PVector translation = new PVector(round(shipLoc.x), round(shipLoc.y));
noFill();
int shipW = 10; //ship width.
int shipH = 27; //ship height.
int rp = 8; //point of flight.

//audio_enabled flame visual for thrusters.

if (thrustOn = true)
{
      
getVolume();

stroke(204, 102, 10);

PVector flameTip = new PVector(0, shipH-rp + shipH*0.5);
PVector flameLeft = new PVector(-shipW+2, shipH-rp);
PVector flameRight = new PVector(shipW-2, shipH-rp);

transform(flameTip, flight, translation);
transform(flameLeft, flight, translation);
transform(flameRight, flight, translation);

//thruster graphic controlled by voice/pitch.
tint(255, 255, 255, 254);
image(fade, 0, 0, width+1, height+3);
noTint();

for(int i = 0; i < fft.avgSize(); i++)
{

strokeWeight(4);
color myFill = color(random(0),random(200),random(180),100);
stroke(myFill);

line(flameLeft.x + x0, flameLeft.y-volume, flameLeft.x + 0 + x0, flameLeft.y-volume - fft.getAvg(i) * -3.3);
line(flameLeft.x + x0 +5, flameLeft.y-volume, flameLeft.x + 5 + x0, flameLeft.y-volume - fft.getAvg(i) * -2.3);
line(flameLeft.x + x0 +10, flameLeft.y-volume, flameLeft.x + 10 + x0, flameLeft.y-volume - fft.getAvg(i) * -2.3);
line(flameLeft.x + x0 +15, flameLeft.y-volume, flameLeft.x + 15 + x0, flameLeft.y-volume - fft.getAvg(i) * -3.3);

}
fade = get(0, 0, width+1, height+3);
fade = get(0, 0, width+1, height+3);
}

//draws ship.

stroke (255, 10, 0);
strokeWeight (2);

PVector shipTip = new PVector (0, -rp);
PVector shipLeft = new PVector (-shipW, shipH-rp);
PVector shipRight = new PVector (shipW, shipH-rp);

transform(shipTip, flight, translation);
transform(shipLeft, flight, translation);
transform(shipRight, flight, translation);

line (shipTip.x + x0, shipTip.y-volume, shipLeft.x + x0, shipLeft.y-volume);
line (shipTip.x + x0, shipTip.y-volume, shipRight.x + x0, shipRight.y-volume);
line (shipLeft.x + x0, shipLeft.y-volume, shipRight.x + x0, shipRight.y-volume);

}

void transform (PVector p, float flight, PVector translation)

{
float x = p.x;
float y = p.y;
p.x = x * cos(flight) - y * sin(flight);
p.y = x * sin(flight) + y * cos(flight);

p.add(translation);
}

//Closes all Minim functions, closes audio when not in use.

void stop(){
in.close();
minim.stop();
super.stop();
}

