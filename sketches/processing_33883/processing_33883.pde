
/* we keep an array of PVectors in array 'frontier'
the background is generated by updating the PVectors, then connecting them with curveVector() and filling in the resulting shape
*/

class Painter {
  boolean finished = false;
  PVector[] frontier = new PVector[30];
  
  Painter() {
    for (int i = 0; i < frontier.length; i++) {
      /*
      initialize a new PVector. 
      Vertically they are evenly distributed from the top to the bottom of the canvas.
      The farther it is vertically from the center of the canvas, the farther left it is.
      */
      PVector edpt = new PVector(abs(canvaswidth/2 - (canvaswidth*i/frontier.length)) - canvaswidth/2, (i*canvasheight)/frontier.length, 0);
      frontier[i] = edpt;
    }
  }
  
  //generate fill color based on noise from timefactor, which is constantly incrementing
  void prepareFill() {
    fill(255 * noise(timefactor*2), 255*noise(timefactor*2 + 300), 0, 3);
  }
  
  //generate stroke and strokeweight based on noise from timefactor
  void prepareStroke() {
    stroke(noise(timefactor + 900) * 255, noise(timefactor - 900) * 100, 0, noise(timefactor)*255);
    strokeWeight(noise(timefactor*10) + 1);
  }
  
  void update() {
    if (finished == false) {
      //first set finished to true. If we later find anything that isn't done we set it back to false.
      finished = true;
      //update each point
      for (int i = 0; i < frontier.length; i++) {
        PVector edpt = frontier[i];
        //totally random incrementation, I don't know why I chose these numbers
        edpt.x += noise(edpt.x * 0.01 + timefactor, edpt.y * 0.01 + timefactor)*6;
        edpt.y += noise(edpt.x * 0.01 - timefactor, edpt.y * 0.01 - timefactor)*6 - 3;  
      }
      noStroke();
      prepareFill();
      //now that we are done updating the PVector positions, draw a curve along them
      beginShape();
      for (int i = 0; i < frontier.length; i++) {
        curveVertex(frontier[i].x, frontier[i].y);
      }
      endShape();
      noSmooth();
      prepareStroke();
      for (int i = 0; i < frontier.length; i++) {
        //draw the dotted lines
        point(frontier[i].x, frontier[i].y);
        if (frontier[i].x < canvaswidth) {
          finished = false;
        } 
        //if we are lucky, generate a new tree
        if (random(0, 400) < (noise(timefactor*10) + 1)) {
          if (frontier[i].y >= 0 && frontier[i].y < canvasheight) {
            Tree newtree = new Tree(frontier[i].x, frontier[i].y, 10);
            trees.add(newtree);
          }
        }
      }
    }
    smooth();
    noStroke();
  }
}

