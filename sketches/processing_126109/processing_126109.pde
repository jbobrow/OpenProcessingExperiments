
/******************************************************************************
 This Processing sketch has been auto-generated by the MoinMoin MathVision
 plugin (http://ten.homelinux.net/productivity/MathVision).

 It combines user-crafted specific code, the formula (see the comment
 /// Start of user formula
 below), as well as rendering code (the MathVision application).

 Credits:
 - Processing, see http://processingjs.org/
 - MathVision (C) by Pascal Bauermeister.
 - User formula (C) by its author.

 MathVision is inspired by and dedicated to the Amiga MathVISION
 software, see http://home.olympus.net/~7seas/ 
 *****************************************************************************/

/////////////////// Defaults
color RGB(x, y) {
  return color(R(x, y), G(x, y), B(x, y));
}

color RGB1(x, y, t) {
  return RGB(x, y);
}

color RGB2(x, y, t) {
  return RGB(x, y, t);
}

int AUTO = -1; // constant

int WIDTH = 640;
float RATIO = 4/3;
int HEIGHT = 0;

float X_MIN = 0;
float X_MAX = 1;

float Y_MIN = 0;
float Y_MAX = 1/RATIO;

int R(x, y) { return ((x*255*3)/X_SPAN) % 256; }
int G(x, y) { return ((y*255*3)/Y_SPAN) % 256; }
int B(x, y) { return 256*(y*X_SPAN+x)/(X_SPAN*Y_SPAN); }

bool preDraw(t) { return true; }
void postDraw(t) { }
void preSetup() { }

float TIME_INCREMENT = 0;
bool CLICK_PAUSE = false;
bool OUT_PAUSE = true;
bool MOUSE_MOVE = false;

/////////////////// Start of user formula
  WIDTH = 250;
  RATIO = 1;
  TIME_INCREMENT = 0.4;
  X_MIN = -20; X_MAX = 20;
  Y_MIN = -20; Y_MAX = 20;

  color RGB(x, y, t) {
    float d1 = dist(u, v, 50, 50) / WIDTH * 9.5;          // top-left star
    float d2 = dist(u, v, mouseX, mouseY) / WIDTH * 9.5;  // mouse-following star
    float d3 = dist(50, 50, mouseX, mouseY) / WIDTH;      // stars fusion

    float pattern = pow(cos(x-t/6) * sin(y+t/2) +1, -1/d2);

    float luma = (pattern) * 127;
    float d = d1*d2*d3;
    return color(luma/d, luma/d - mouseY, luma/d - mouseX); // mouse makes color shift
  }
/////////////////// End of user formula

int u;
int v;
float t = 0;
int i = 0;
int t_on = true;
int X_SPAN;
int Y_SPAN;

void setup() {
  X_SPAN = X_MAX - X_MIN;
  Y_SPAN = Y_MAX - Y_MIN;
  if(RATIO==AUTO) {
    RATIO = X_SPAN / Y_SPAN;
  }
  if(HEIGHT==0) {
    HEIGHT = (int)(WIDTH/RATIO + 0.5);
  }

  v = 0;

  size((int)WIDTH, (int)HEIGHT);
  noStroke();
  background(255);

  // for first frame, simulate centered mouse
  mouseX = WIDTH/2;
  mouseY = HEIGHT/2;

  // user init
  preSetup();

  // draw first frame
  drawFrame(0, TIME_INCREMENT==0 ? RGB1 : RGB2);

  if(OUT_PAUSE)
    noLoop();

  if("" != "")
    js_mathvision_done_1a1f3ede2a1fb909d3afcfc987bd0668b733736a("", 0);
}

void drawFrame(t, func)
{
  if(preDraw(t)) {
    loadPixels();
    for(v=0; v<HEIGHT; v++) {
      int y = map(v, 0, HEIGHT, Y_MIN, Y_MAX);
      for(u=0; u<WIDTH; u++) {
        int x = map(u, 0, WIDTH, X_MIN, X_MAX);
        pixels[u+v*width] = func(x, y, t);
      }
    }
    updatePixels();

    postDraw(t);

    if(false) {
      ++i;
      js_mathvision_add_1a1f3ede2a1fb909d3afcfc987bd0668b733736a(i);
    }
  }
}

void draw()
{
  if(TIME_INCREMENT==0) {
    noLoop();
  }
  else {
    t += TIME_INCREMENT;
    drawFrame(t, RGB2);
  }
}

void mouseClicked() {
  if(TIME_INCREMENT!=0 && CLICK_PAUSE) {
    t_on = !t_on;
    if(t_on)
      loop();
    else
      noLoop();
  }
}

void mouseOver() {
  if(OUT_PAUSE && TIME_INCREMENT!=0)
    loop();
}

void mouseOut() {
  if(OUT_PAUSE)
    noLoop();
}

void mouseMoved() {
  if(TIME_INCREMENT==0 && MOUSE_MOVE)
    drawFrame(0, RGB1);
}
